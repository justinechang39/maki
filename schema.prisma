generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * ============== ==
 * USER TABLE
 * ================
 * This now holds the minimal global user info, such as a unique ID and email.
 * No tenant-specific or profile data is kept here anymore.
 */
model User {
  id        String   @id @default(ulid())
  email     String?  @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationship to TenantUser
  tenantUsers TenantUser[]
}

/**
 * ================
 * TENANT TABLE
 * ================
 */
model Tenant {
  id                 String    @id
  name               String    @unique
  email              String? // Primary contact/billing email for the tenant
  country            String? // Country where the organization is based
  timezone           String    @default("Asia/Singapore") // Timezone for the tenant
  onboardingComplete Boolean   @default(false)
  isActive           Boolean   @default(true)
  deactivatedAt      DateTime?
  deactivationReason String?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  // Relationship to user invitations
  userInvitations UserInvitations[]
  // Relationship to TenantUser
  tenantUsers     TenantUser[]
  tenantUserRoles TenantUserRole[]

  // Relationship to other domain entities
  CommentSection           CommentSection[]
  Course                   Course[]
  Subject                  Subject[]
  Class                    Class[]
  CourseStudent            CourseStudent[]
  ClassStudent             ClassStudent[]
  Thread                   Thread[]
  tenantSettings           TenantSettings?
  Comment                  Comment[]
  CommentAttachment        CommentAttachment[]
  BranchLocation           BranchLocation[]
  Announcement             Announcement[]
  teacherInternalNotes     TeacherInternalClassNotes[]
  teacherExternalNotes     TeacherExternalClassNotes[]
  studentNotes             StudentClassNotes[]
  StudentParentLink        StudentParentLink[]
  StudentAvailabilityEvent StudentEvent[]
  School                   School[]
  // Added for Groups:
  groups                   Group[]
  CalendarEvent            CalendarEvent[]

  userFeedback            UserFeedback[]
  CourseEnrollmentHistory CourseEnrollmentHistory[]

  // Billing and usage history relations
  tenantUserStatusHistory TenantUserStatusHistory[]
  tenantBillingSettings   TenantBillingSettings[]
  billingInvoices         BillingInvoice[]
  payments                Payment[]
  noteTemplates           NoteTemplate[]

  // Payment Provider Integration
  paymentProvider                String? // e.g., "stripe"
  paymentProviderCustomerId      String? @unique // ID of the customer in the payment provider system
  paymentProviderPaymentMethodId String? @unique // ID of the saved payment method from the provider (e.g., HitPay's payment_method_id)
  hitpayProvisionalRecurringId   String? // Stores the provisional recurring ID from HitPay session creation

  @@index([name])
  @@index([createdAt])
}

/**
 * ====================================
 * TENANTUSER (the "join" between User and Tenant)
 * ====================================
 * This is the table that identifies a single user in a particular tenant.
 * All other tenant-specific data now relates to this table instead of userId.
 */
model TenantUser {
  id                 String   @id @default(ulid())
  userId             String
  tenantId           String
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  onboardingComplete Boolean? @default(false)
  hasPortalAccess    Boolean  @default(false) // Track if user has portal access
  isActive           Boolean  @default(true)

  userSettings Json? // User-specific settings stored as JSON

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // One-to-one or one-to-many with the profiles
  userProfile    UserProfile?
  teacherProfile TeacherProfile?
  studentProfile StudentProfile?
  parentProfile  ParentProfile?
  adminProfile   AdminProfile?
  contactInfo    ContactInfo?

  // TenantUserRole relation
  tenantUserRoles TenantUserRole[]

  // Other relations
  courseStudents       CourseStudent[]
  classStudents        ClassStudent[]
  comments             Comment[]
  teacherInternalNotes TeacherInternalClassNotes[]
  teacherExternalNotes TeacherExternalClassNotes[]
  studentNotes         StudentClassNotes[]
  Course               Course[]
  Class                Class[]
  studentLinks         StudentParentLink[]         @relation("StudentLink")
  parentLinks          StudentParentLink[]         @relation("ParentLink")

  // Opposite relation fields for other relations
  invitationsSent     UserInvitations[] @relation("InviteSender")
  invitationsReceived UserInvitations[] @relation("Invitee")
  studentEvents       StudentEvent[]
  groupExamResults    GroupExamResult[]

  submittedFeedback       UserFeedback[]
  feedbackVotes           FeedbackVote[]
  CourseEnrollmentHistory CourseEnrollmentHistory[]

  // Activation/deactivation history
  statusHistory TenantUserStatusHistory[]

  // Invoice line items for this user
  invoiceLineItems InvoiceLineItem[]
  noteTemplates    NoteTemplate[]

  // Recently used templates and preferences stored in userSettings Json

  @@unique([userId, tenantId])
  @@index([userId, tenantId])
  @@index([tenantId])
}

enum ContactRelationship {
  PARENT
  SPOUSE
  SIBLING
  GRANDPARENT
  FRIEND
  COLLEAGUE
  OTHER
}

model ContactInfo {
  id               String  @id @default(ulid())
  tenantUserId     String  @unique
  alternativeEmail String?
  phoneNumber      String?

  // Address information
  address    String?
  city       String?
  state      String?
  country    String?
  postalCode String?

  // Emergency contact
  emergencyContactName         String?
  emergencyContactRelationship ContactRelationship?
  emergencyContactPhone        String?
  emergencyContactEmail        String?

  // For students (medical information)
  medicalConditions String?
  allergies         String?
  medications       String?

  // Demographic information
  dateOfBirth DateTime?
  nationality String?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relation to tenant user
  tenantUser TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)

  @@index([tenantUserId])
}

/**
 * ====================================
 * USER PROFILES (tenant-scoped)
 * ====================================
 * The core tenant-specific user profile information can live here.
 */
model UserProfile {
  id                     String   @id @default(ulid())
  tenantUserId           String   @unique
  firstName              String?
  lastName               String?
  displayName            String?
  profilePictureFileType String?
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt

  tenantUser TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)
}

/**
 * ====================================
 * ROLE-SPECIFIC PROFILES
 * ====================================
 * Each role can have fields that make sense for that role alone (examples below).
 */
model TeacherProfile {
  id           String   @id @default(ulid())
  tenantUserId String   @unique
  specialty    String?
  bio          String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  tenantUser TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)
}

model StudentProfile {
  id             String   @id @default(ulid())
  tenantUserId   String   @unique
  graduatingYear Int?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  tenantUser TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)

  studentGroupMemberships       StudentGroupMembership[]
  StudentInternalCommentSection StudentInternalCommentSection?
  StudentExternalCommentSection StudentExternalCommentSection?
  School                        School?                        @relation(fields: [schoolId], references: [id])
  schoolId                      String?
}

model ParentProfile {
  id           String   @id @default(ulid())
  tenantUserId String   @unique
  childrenInfo Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  tenantUser TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)
}

model AdminProfile {
  id           String   @id @default(ulid())
  tenantUserId String   @unique
  department   String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  tenantUser TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)
}

/**
 * ====================================
 * TENANT SETTINGS
 * ====================================
 */
model TenantSettings {
  tenantId  String   @id @unique
  settings  Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
}

model UserInvitations {
  id       String @id @default(ulid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // The tenant user sending the invitation
  inviterTenantUserId String
  inviterTenantUser   TenantUser @relation("InviteSender", fields: [inviterTenantUserId], references: [id], onDelete: Cascade)

  // The tenant user receiving the invitation
  inviteeTenantUserId String
  inviteeTenantUser   TenantUser @relation("Invitee", fields: [inviteeTenantUserId], references: [id], onDelete: Cascade)

  token   String    @unique
  expires DateTime
  used    Boolean   @default(false)
  usedAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([inviteeTenantUserId, tenantId])
  @@index([tenantId])
  @@index([inviteeTenantUserId])
  @@index([inviterTenantUserId])
}

enum UserRoles {
  ADMIN
  TEACHER
  PARENT
  STUDENT
  NO_ROLE
}

model TenantUserRole {
  id           String    @id @default(ulid())
  tenantUserId String
  role         UserRoles
  tenantId     String
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  tenantUser TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)
  tenant     Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantUserId, tenantId, role])
  @@index([tenantUserId, tenantId])
  @@index([tenantId])
}

/**
 * ====================================
 * SUBJECT
 * ====================================
 */
model Subject {
  id        String   @id @default(ulid())
  name      String
  tenantId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  infos  CourseOrClassInfo[]
  // Added for Groups:
  groups Group[]

  @@unique([name, tenantId])
  @@index([name])
  @@index([tenantId])
}

model CourseOrClassInfo {
  id          String  @id @default(ulid())
  name        String
  description String
  subjectId   String
  subject     Subject @relation(fields: [subjectId], references: [id], onDelete: Cascade)

  // Relationships to Course and Class
  course Course?
  class  Class?

  // Indexes
  @@index([subjectId])
}

/**
 * ====================================
 * COURSE
 * ====================================
 * Now references defaultTeacherTenantUserId instead of a global userId.
 */
model Course {
  id     String            @id @default(ulid())
  infoId String            @unique // Add @unique here
  info   CourseOrClassInfo @relation(fields: [infoId], references: [id], onDelete: Cascade)

  defaultTeacherTenantUserId String
  defaultTeacher             TenantUser @relation(fields: [defaultTeacherTenantUserId], references: [id])

  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  classes                 Class[]
  students                CourseStudent[]
  commentSectionId        String?                   @unique
  commentSection          CommentSection?           @relation(fields: [commentSectionId], references: [id])
  Announcement            Announcement[]
  CourseCommentSection    CourseCommentSection?
  CourseEnrollmentHistory CourseEnrollmentHistory[]

  @@index([tenantId])
  @@index([defaultTeacherTenantUserId])
  @@index([infoId])
}

model CourseEnrollmentHistory {
  id           String        @id @default(ulid())
  courseId     String
  tenantUserId String
  tenantId     String
  startDate    DateTime      @default(now())
  endDate      DateTime? // null means currently active
  status       StudentStatus
  reason       String? // Optional reason for status change

  course     Course     @relation(fields: [courseId], references: [id], onDelete: Cascade)
  tenantUser TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)
  tenant     Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([courseId])
  @@index([tenantUserId])
  @@index([tenantId])
  @@index([startDate])
  @@index([endDate])
}

/**
 * ====================================
 * CLASS
 * ====================================
 * Now references teacherTenantUserId (optional).
 */
enum ClassStatus {
  SCHEDULED
  CANCELLED
  COMPLETED
}

model Class {
  id                  String             @id @default(ulid())
  courseId            String? // Optional for one-off classes
  course              Course?            @relation(fields: [courseId], references: [id], onDelete: Cascade)
  infoId              String?            @unique
  info                CourseOrClassInfo? @relation(fields: [infoId], references: [id], onDelete: Cascade)
  teacherTenantUserId String?
  teacherTenantUser   TenantUser?        @relation(fields: [teacherTenantUserId], references: [id], onDelete: Cascade)
  tenantId            String
  tenant              Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  replacingClassId String?
  replacingClass   Class?  @relation("ClassReplacement", fields: [replacingClassId], references: [id])
  replacedBy       Class[] @relation("ClassReplacement")

  students             ClassStudent[]
  commentSectionId     String?                     @unique
  commentSection       CommentSection?             @relation(fields: [commentSectionId], references: [id])
  classLocationId      String?
  classLocation        ClassLocation?              @relation(fields: [classLocationId], references: [id])
  status               ClassStatus                 @default(SCHEDULED)
  Announcement         Announcement[]
  teacherInternalNotes TeacherInternalClassNotes[]
  teacherExternalNotes TeacherExternalClassNotes[]
  studentNotes         StudentClassNotes[]
  ClassCommentSection  ClassCommentSection?

  // Link to calendar event
  calendarEvent CalendarEvent?

  @@index([courseId])
  @@index([tenantId])
  @@index([infoId])
  @@index([teacherTenantUserId])
  @@index([replacingClassId])
}

/**
 * ====================================
 * BRANCH LOCATION & CLASS LOCATION
 * ====================================
 */
model BranchLocation {
  id             String          @id @default(ulid())
  tenantId       String
  tenant         Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name           String
  address        String?
  city           String?
  state          String?
  country        String?
  postalCode     String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  classLocations ClassLocation[]

  @@unique([name, tenantId])
  @@index([tenantId])
}

model ClassLocation {
  id          String         @id @default(ulid())
  branchId    String
  branch      BranchLocation @relation(fields: [branchId], references: [id], onDelete: Cascade)
  roomNumber  String?
  maxStudents Int?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  classes Class[]

  @@index([branchId])
}

/**
 * ====================================
 * COURSESTUDENT (Join Table)
 * ====================================
 * Replaces userId with tenantUserId, no longer needs an ID.
 */
enum StudentStatus {
  ACTIVE
  INACTIVE
  WITHDRAWN
}

model CourseStudent {
  courseId     String
  tenantUserId String
  tenantId     String
  joinedAt     DateTime      @default(now())
  status       StudentStatus @default(ACTIVE)

  course     Course     @relation(fields: [courseId], references: [id], onDelete: Cascade)
  tenantUser TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)
  tenant     Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@id([courseId, tenantUserId])
  @@index([tenantId])
}

/**
 * ====================================
 * CLASSSTUDENT (Join Table)
 * ====================================
 * Replaces userId with tenantUserId, no ID needed.
 */
enum AttendanceStatus {
  PRESENT
  ABSENT
  WILL_NOT_ATTEND
  NOT_MARKED
  PRESENT_BUT_LATE
}

enum ClassStudentType {
  REGULAR
  TRIAL
}

model ClassStudent {
  classId            String
  tenantUserId       String
  tenantId           String
  attendanceStatus   AttendanceStatus @default(NOT_MARKED)
  absenceReason      String?
  notes              String?
  studentType        ClassStudentType @default(REGULAR)
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  lateArrivalTime    DateTime?
  participationScore Int?
  focusScore         Int?
  preparationScore   Int?
  behaviorScore      Int?
  understandingScore Int?
  isDraft            Boolean          @default(true)

  class      Class      @relation(fields: [classId], references: [id], onDelete: Cascade)
  tenantUser TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)
  tenant     Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@id([classId, tenantUserId])
  @@index([tenantId])
}

/**
 * ====================================
 * COMMENT SECTION & THREAD & MESSAGE
 * ====================================
 * The Message table now references tenantUserId instead of userId.
 */
model CommentSection {
  id                            String                         @id @default(ulid())
  tenantId                      String
  createdAt                     DateTime                       @default(now())
  updatedAt                     DateTime                       @updatedAt
  threads                       Thread[]
  tenant                        Tenant                         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  Course                        Course?
  Class                         Class?
  StudentInternalCommentSection StudentInternalCommentSection?
  StudentExternalCommentSection StudentExternalCommentSection?
  CourseCommentSection          CourseCommentSection?
  ClassCommentSection           ClassCommentSection?

  @@index([tenantId])
}

model Thread {
  id               String         @id @default(ulid())
  commentSectionId String
  commentSection   CommentSection @relation(fields: [commentSectionId], references: [id], onDelete: Cascade)
  tenantId         String
  tenant           Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  title            String
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  comments         Comment[]
  isPinned         Boolean        @default(false)

  @@index([commentSectionId])
  @@index([tenantId])
}

model Comment {
  id           String   @id @default(ulid())
  threadId     String
  tenantId     String
  content      Json
  tenantUserId String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  thread      Thread              @relation(fields: [threadId], references: [id], onDelete: Cascade)
  tenant      Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantUser  TenantUser          @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)
  attachments CommentAttachment[]

  @@index([threadId])
  @@index([tenantUserId])
  @@index([tenantId])
}

model CommentAttachment {
  id        String   @id @default(ulid())
  commentId String
  tenantId  String
  fileType  String
  fileUrl   String
  fileName  String
  fileSize  Int
  createdAt DateTime @default(now())

  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  tenant  Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([commentId])
  @@index([tenantId])
}

model StudentInternalCommentSection {
  id               String   @id @default(ulid())
  studentProfileId String   @unique
  commentSectionId String   @unique
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  studentProfile StudentProfile @relation(fields: [studentProfileId], references: [id], onDelete: Cascade)
  commentSection CommentSection @relation(fields: [commentSectionId], references: [id], onDelete: Cascade)

  @@unique([commentSectionId, studentProfileId])
}

model StudentExternalCommentSection {
  id               String   @id @default(ulid())
  studentProfileId String   @unique
  commentSectionId String   @unique
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  studentProfile StudentProfile @relation(fields: [studentProfileId], references: [id], onDelete: Cascade)
  commentSection CommentSection @relation(fields: [commentSectionId], references: [id], onDelete: Cascade)

  @@unique([commentSectionId, studentProfileId])
}

model CourseCommentSection {
  id               String   @id @default(ulid())
  courseId         String   @unique
  commentSectionId String   @unique
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  course         Course         @relation(fields: [courseId], references: [id], onDelete: Cascade)
  commentSection CommentSection @relation(fields: [commentSectionId], references: [id], onDelete: Cascade)
}

model ClassCommentSection {
  id               String   @id @default(ulid())
  classId          String   @unique
  commentSectionId String   @unique
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  class          Class          @relation(fields: [classId], references: [id], onDelete: Cascade)
  commentSection CommentSection @relation(fields: [commentSectionId], references: [id], onDelete: Cascade)
}

/**
 * ====================================
 * ANNOUNCEMENTS
 * ====================================
 * No user reference was here, so no changes needed beyond normal usage.
 */
model Announcement {
  id        String   @id @default(ulid())
  title     String
  content   String
  courseId  String?
  classId   String?
  tenantId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  course Course? @relation(fields: [courseId], references: [id], onDelete: Cascade)
  class  Class?  @relation(fields: [classId], references: [id], onDelete: Cascade)
  tenant Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([courseId])
  @@index([classId])
  @@index([tenantId])
}

/**
 * ====================================
 * TEACHER FEEDBACK
 * ====================================
 * Instead of (userId, classId) we now use (tenantUserId, classId).
 * We can drop the separate ID field if we want a composite PK.
 */
model TeacherInternalClassNotes {
  tenantUserId String
  classId      String
  tenantId     String
  note         String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  isDraft      Boolean  @default(true)

  tenantUser TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)
  class      Class      @relation(fields: [classId], references: [id], onDelete: Cascade)
  tenant     Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@id([tenantUserId, classId])
  @@index([tenantId])
}

model TeacherExternalClassNotes {
  tenantUserId String
  classId      String
  tenantId     String
  note         String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  isDraft      Boolean  @default(true)

  tenantUser TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)
  class      Class      @relation(fields: [classId], references: [id], onDelete: Cascade)
  tenant     Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@id([tenantUserId, classId])
  @@index([tenantId])
}

model StudentClassNotes {
  tenantUserId String
  classId      String
  tenantId     String
  note         String // Note visible only to the student
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  tenantUser TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)
  class      Class      @relation(fields: [classId], references: [id], onDelete: Cascade)
  tenant     Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@id([tenantUserId, classId])
  @@index([tenantId])
}

model StudentParentLink {
  id            String   @id @default(ulid())
  studentUserId String
  parentUserId  String
  tenantId      String
  relationship  String? // e.g. "Mother", "Father", "Guardian"
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  student TenantUser @relation("StudentLink", fields: [studentUserId], references: [id], onDelete: Cascade)
  parent  TenantUser @relation("ParentLink", fields: [parentUserId], references: [id], onDelete: Cascade)
  tenant  Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([studentUserId, parentUserId, tenantId])
  @@index([studentUserId])
  @@index([parentUserId])
  @@index([tenantId])
}

model StudentEvent {
  id           String     @id @default(ulid())
  tenantUserId String
  tenantUser   TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)
  tenantId     String
  tenant       Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  // Link to calendar event
  calendarEvent CalendarEvent?

  @@index([tenantUserId])
  @@index([tenantId])
}

model School {
  id         String   @id @default(ulid())
  tenantId   String
  tenant     Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name       String
  address    String?
  city       String?
  state      String?
  country    String?
  postalCode String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  studentProfiles StudentProfile[]
  // Added for Groups:
  groups          Group[]

  @@unique([tenantId, name])
  @@index([tenantId])
}

/**
 * Grade table (e.g. "Secondary 1", "Secondary 2", etc.)
 */
model Grade {
  id        String   @id @default(ulid())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  tenantId  String

  groups Group[]

  @@unique([tenantId, name])
  @@index([tenantId])
}

/**
 * Stream table (e.g. "Express", "N(A)", "N(T)")
 */
model Stream {
  id        String   @id @default(ulid())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  tenantId  String

  groups Group[]

  @@unique([tenantId, name])
  @@index([tenantId])
}

/**
 * Group table: defined by School, Grade, Stream, and Subject.
 * Also linked to a Tenant.
 */
model Group {
  id        String   @id @default(ulid())
  tenantId  String
  schoolId  String
  gradeId   String
  streamId  String
  subjectId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant  Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  school  School  @relation(fields: [schoolId], references: [id])
  grade   Grade   @relation(fields: [gradeId], references: [id])
  stream  Stream  @relation(fields: [streamId], references: [id])
  subject Subject @relation(fields: [subjectId], references: [id])

  // Updated join relation: using StudentGroupMembership now
  studentGroupMemberships StudentGroupMembership[]
  groupExams              GroupExam[]

  @@unique([tenantId, schoolId, gradeId, streamId, subjectId])
  @@index([tenantId])
}

/**
 * Join table for the many-to-many relationship between Group and StudentProfile.
 */
model StudentGroupMembership {
  groupId          String
  studentProfileId String
  joinedAt         DateTime @default(now())
  tenantId         String

  group          Group          @relation(fields: [groupId], references: [id], onDelete: Cascade)
  studentProfile StudentProfile @relation(fields: [studentProfileId], references: [id], onDelete: Cascade)

  @@id([groupId, studentProfileId])
  @@index([studentProfileId])
  @@index([tenantId])
}

/**
 * GroupExam: An exam that is associated with a specific Group.
 * Includes exam date/time and notes for exam coverage.
 */
model GroupExam {
  id      String @id @default(ulid())
  groupId String
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  tenantId  String

  examResults GroupExamResult[]

  // Link to calendar event
  calendarEvent CalendarEvent?

  @@index([groupId])
  @@index([tenantId])
}

model GroupExamResult {
  id           String   @id @default(ulid())
  groupExamId  String
  tenantUserId String
  score        String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  tenantId     String

  groupExam  GroupExam  @relation(fields: [groupExamId], references: [id], onDelete: Cascade)
  tenantUser TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)

  @@unique([groupExamId, tenantUserId])
  @@index([groupExamId])
  @@index([tenantUserId])
  @@index([tenantId])
}

// Base calendar event model// Base calendar event model
model CalendarEvent {
  id          String  @id @default(ulid())
  title       String
  description String?

  // Date range
  startDate DateTime // YYYY-MM-DD for the starting date
  endDate   DateTime // YYYY-MM-DD for the ending date

  // Time components (optional)
  startTimeMinutes Int? // Minutes since midnight on startDate
  endTimeMinutes   Int? // Minutes since midnight on endDate

  // Time classification
  timeSpecification TimeSpecification @default(DATE_ONLY)
  isAllDay          Boolean           @default(false) // For backward compatibility
  location          String?
  color             String? // For UI categorization
  status            EventStatus       @default(SCHEDULED)
  visibility        EventVisibility   @default(DEFAULT)

  // Common metadata
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Polymorphic relationship - exactly one of these must be set
  eventType      EventType
  classId        String?       @unique
  class          Class?        @relation(fields: [classId], references: [id], onDelete: Cascade)
  studentEventId String?       @unique
  studentEvent   StudentEvent? @relation(fields: [studentEventId], references: [id], onDelete: Cascade)
  groupExamId    String?       @unique
  groupExam      GroupExam?    @relation(fields: [groupExamId], references: [id], onDelete: Cascade)

  // For recurring events
  recurringEventId String?
  recurringEvent   RecurringEvent? @relation(fields: [recurringEventId], references: [id])

  // For modified instances
  exceptionFor RecurringEventException? @relation("ModifiedEvent")

  @@index([tenantId])
  @@index([startDate])
  @@index([endDate])
  @@index([eventType])
  @@index([recurringEventId])
}

// Recurring event definition
model RecurringEvent {
  id              String    @id @default(ulid())
  recurrenceRule  String // iCalendar RRULE format
  recurrenceStart DateTime
  recurrenceEnd   DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  calendarEvents CalendarEvent[]
  exceptions     RecurringEventException[]
}

// Exceptions to recurring events
model RecurringEventException {
  id               String         @id @default(ulid())
  recurringEventId String
  recurringEvent   RecurringEvent @relation(fields: [recurringEventId], references: [id], onDelete: Cascade)

  // The original date this exception applies to
  originalDate DateTime

  // Type of exception
  exceptionType ExceptionType

  // If MODIFIED, this points to the new event (with modified properties)
  modifiedEventId String?        @unique
  modifiedEvent   CalendarEvent? @relation("ModifiedEvent", fields: [modifiedEventId], references: [id])

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([recurringEventId, originalDate])
  @@index([recurringEventId])
  @@index([originalDate])
}

// Enums for the calendar system
enum TimeSpecification {
  DATE_ONLY // Just the dates matter (birthdays, holidays)
  START_TIME_ONLY // Has start time but no end time (deadlines)
  TIME_RANGE // Has specific start and end times
}

enum EventType {
  CLASS
  STUDENT_EVENT
  GROUP_EXAM
}

enum EventStatus {
  SCHEDULED
  CANCELLED
  COMPLETED
  RESCHEDULED
}

enum EventVisibility {
  DEFAULT
  PUBLIC
  PRIVATE
  CONFIDENTIAL
}

enum ExceptionType {
  CANCELLED // This occurrence is cancelled/deleted
  MODIFIED // This occurrence is modified (time/location/etc changed)
}

/**
 * ====================================
 * USER FEEDBACK SYSTEM
 * ====================================
 */
enum FeedbackType {
  FEATURE_REQUEST
  BUG_REPORT
  GENERAL_FEEDBACK
}

enum FeedbackStatus {
  OPEN
  UNDER_REVIEW
  PLANNED
  IN_PROGRESS
  COMPLETED
  DECLINED
  DUPLICATE
  CANNOT_REPRODUCE // Specific for bug reports
  FIXED // Specific for bug reports
  HIDDEN // For sensitive or inappropriate feedback
}

model UserFeedback {
  id          String         @id @default(ulid())
  title       String
  description String
  type        FeedbackType
  status      FeedbackStatus @default(OPEN)
  tenantId    String
  tenant      Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Who submitted the feedback
  submitterTenantUserId String
  submitter             TenantUser @relation(fields: [submitterTenantUserId], references: [id], onDelete: Cascade)

  // Bug-specific fields
  severity         BugSeverity? // Only relevant for bug reports
  stepsToReproduce String? // Only relevant for bug reports

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  votes FeedbackVote[]

  @@index([tenantId])
  @@index([submitterTenantUserId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
}

enum BugSeverity {
  CRITICAL
  HIGH
  MEDIUM
  LOW
  TRIVIAL
}

/**
 * Votes on feedback items
 */
model FeedbackVote {
  feedbackId   String
  tenantUserId String
  createdAt    DateTime @default(now())

  feedback   UserFeedback @relation(fields: [feedbackId], references: [id], onDelete: Cascade)
  tenantUser TenantUser   @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)

  @@id([feedbackId, tenantUserId])
  @@index([feedbackId])
  @@index([tenantUserId])
}

// Enums for billing
enum TenantUserActivityType {
  ACTIVATED
  DEACTIVATED
}

enum InvoiceStatus {
  DRAFT
  ISSUED
  PAID
  PARTIALLY_PAID
  OVERDUE
  VOID
  UNCOLLECTIBLE
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
  REFUNDED
}

enum NoteType {
  INTERNAL       // Teacher's internal notes
  EXTERNAL       // Teacher's external notes
  STUDENT_NOTES  // Student's notes
}

model NoteTemplate {
  id           String   @id @default(ulid())
  name         String   // Template name
  content      String   // Template content
  noteType     NoteType // Type of note this template is for
  isOrgWide    Boolean  @default(false) // Whether this is an org-wide template or personal
  lastUsedAt   DateTime? // Track when template was last used
  tenantId     String
  tenantUserId String // The teacher or admin who created this template
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  tenant     Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantUser TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([tenantUserId])
  @@index([isOrgWide])
}

// Model to track user activation/deactivation history
model TenantUserStatusHistory {
  id            String                 @id @default(ulid())
  tenantUserId  String
  tenantId      String
  activityType  TenantUserActivityType
  effectiveFrom DateTime // UTC
  effectiveTo   DateTime? // Null = ongoing
  reason        String?
  createdAt     DateTime               @default(now())

  tenantUser TenantUser @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)
  tenant     Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, effectiveFrom, effectiveTo])
  @@index([tenantUserId, effectiveFrom])
}

// Billing settings per tenant
model TenantBillingSettings {
  id                      String   @id @default(ulid())
  tenantId                String
  userMonthlyRate         Decimal  @db.Decimal(10, 4) // rate per user per month
  freeUsersAllowance      Int      @default(0) // number of free users per month
  currency                String   @default("SGD")
  effectiveFrom           DateTime // UTC date when setting takes effect
  applyToFullBillingCycle Boolean  @default(false)
  createdAt               DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, effectiveFrom])
  @@index([tenantId])
}

// Invoice records per billing period
model BillingInvoice {
  id                        String        @id @default(ulid())
  tenantId                  String
  billingPeriodStart        DateTime // UTC (month start)
  billingPeriodEnd          DateTime // UTC (month end)
  daysInBillingPeriod       Int
  calculatedUserDays        Int
  userMonthlyRateApplied    Decimal       @db.Decimal(10, 4)
  freeUsersAllowanceApplied Int
  freeUserDaysAllowance     Int
  billedUserDays            Int
  effectiveUserDayRate      Decimal       @db.Decimal(18, 10)
  currency                  String
  subtotalAmount            Decimal       @db.Decimal(12, 2)
  taxRateApplied            Decimal?      @db.Decimal(4, 4)
  taxAmount                 Decimal?      @db.Decimal(12, 2)
  totalAmountDue            Decimal       @db.Decimal(12, 2)
  status                    InvoiceStatus @default(DRAFT)
  isZeroRated               Boolean       @default(false)
  notes                     String?
  issuedAt                  DateTime?
  dueDate                   DateTime?
  paidAt                    DateTime?
  createdAt                 DateTime      @default(now())
  updatedAt                 DateTime      @updatedAt
  paymentAttemptCount       Int           @default(0) // Track number of payment attempts

  tenant    Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  lineItems InvoiceLineItem[]

  // Payments applied to this invoice
  payments Payment[]

  // Payment Provider Integration
  providerInvoiceId String? @unique // ID of the invoice in the payment provider system

  @@unique([tenantId, billingPeriodStart, billingPeriodEnd])
  @@index([tenantId, status])
  @@index([dueDate])
}

model InvoiceLineItem {
  id           String   @id @default(ulid())
  invoiceId    String
  tenantUserId String
  userDays     Int
  createdAt    DateTime @default(now())

  invoice    BillingInvoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  tenantUser TenantUser     @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)

  @@index([invoiceId])
  @@index([tenantUserId])
}

// Payments toward invoices or prepayments
model Payment {
  id                String        @id @default(ulid())
  tenantId          String
  invoiceId         String? // null = prepayment
  provider          String
  providerReference String?
  amount            Decimal       @db.Decimal(12, 2)
  currency          String        @default("SGD")
  status            PaymentStatus @default(PENDING)
  methodDetails     Json?
  receivedAt        DateTime      @default(now())
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  tenant  Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  invoice BillingInvoice? @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([invoiceId])
}

// Default billing settings set by super admins
model DefaultBillingSettings {
  id                      String    @id @default(ulid())
  userMonthlyRate         Decimal   @db.Decimal(10, 4) // default rate per user per month
  freeUsersAllowance      Int       @default(0) // default number of free users per month
  currency                String    @default("SGD")
  applyToFullBillingCycle Boolean   @default(false)
  isActive                Boolean   @default(true) // only one record should be active at a time
  effectiveFrom           DateTime  @default(now()) // when this default setting became active
  effectiveTo             DateTime? // when this default setting was deactivated
  createdBy               String? // optional reference to the admin who created it
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt

  @@index([isActive])
  @@index([effectiveFrom, effectiveTo])
}

model SampleSchools {
  id         String   @id @default(ulid())
  name       String   @unique
  address    String?
  city       String?
  state      String?
  country    String?
  postalCode String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([name])
}

model SampleGrades {
  id        String   @id @default(ulid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
}

model SampleStreams {
  id        String   @id @default(ulid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
}

model SampleSubjects {
  id        String   @id @default(ulid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
}

model SampleCountries {
  id        String   @id @default(ulid())
  name      String   @unique
  code      String   @unique // ISO country code
  timezone  String?  // IANA timezone string (e.g., "Asia/Singapore")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
  @@index([code])
}

// Model for tenant signup requests with email verification
model TenantSignupRequest {
  id                String    @id @default(ulid())
  email             String
  organizationName  String
  verificationToken String    @unique
  expiresAt         DateTime
  isVerified        Boolean   @default(false)
  verifiedAt        DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([email])
  @@index([verificationToken])
}
